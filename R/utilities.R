#' Calculate the standard deviation of recruitment deviations in an MCMC
#' data frame
#'
#' @param posteriors The MCMC data frame as generated by [r4ss::SSgetMCMC()]
#' @param pattern The regular expression used to match the columns
#'
#' @return A formatted string representing the standard deviation of the
#' recruitment deviations
#' @export
calc_sd_of_devs <- function(posteriors, pattern = "Main") {
  posteriors |>
    select(matches(pattern)) |>
    apply(MARGIN = 1, FUN = sd) |>
    median() |>
    f(2)
}

#' Calculate the men, median, and range of the recruitment deviations in an
#' MCMC data frame
#'
#' @param posteriors The MCMC data frame as generated by [r4ss::SSgetMCMC()]
#' @param pattern The regular expression used to match the columns
#'
#' @return A list of the mean, median, and range of the recruitment deviations
#' @export
calc_sum_rec_devs <- function(posteriors, pattern = "Main") {
  tmp <- posteriors |>
    select(matches(pattern)) |>
    apply(MARGIN = 1, FUN = sum)
  c(mean = mean(tmp),
    median = median(tmp),
    range = range(tmp))
}

#' Place a LaTeX `\\makecell{}` macro around some text
#'
#' @details
#' This function is a wrapper around [kableExtra::linebreak()] which itself
#' does not wrap the makecell macro around strings without the linebreak
#' character. For table headers, this needs to be done to keep all headers
#' aligned the same way with respect to each other.
#'
#' @param x A vector of character strings
#' @param align Choose from "l", "c" or "r" for "left", "center", and "right"
#' respectively
#' @param ... Arguments passed to [kableExtra::linebreak()]
#'
#' @return A vector of modified character strings or `NULL` if `x` is `NULL` or
#' `NA` if `x` is `NA`. Any empty strings will remain the same, without
#' wrapping text
#' @export
linebreaker <- function(x,
                        align = c("l", "c", "r"),
                        ...){

  align <- match.arg(align)
  modded_x <- linebreak(x, align = align, ...)

  # Wrap the strings not wrapped by `linebreak()` above
  inds <- grepl("^\\\\makecell.*\\}", modded_x)
  modded_x[!inds] <- paste0("\\makecell[", align, "]{", modded_x[!inds], "}")

  # Replace empty strings if there were any
  inds <- grepl("^\\\\makecell\\[(l|c|r)\\]\\{\\}$", modded_x)
  modded_x[inds] <- ""

  # Replace NA strings if there were any
  inds <- grepl("^\\\\makecell\\[(l|c|r)\\]\\{NA\\}$", modded_x)
  modded_x[inds] <- NA

  # If NULL was passed in, we will have a zero-length vector here
  if(!length(modded_x)){
    return(NULL)
  }

  modded_x
}

#' Return a data frame of the names and sizes of the objects in a list
#'
#' @param lst The list
#' @param scale A scale factor. If 1e3, return values in kB, if 1e6, GB,
#' 1e12, TB
#' @param desc Logical. If `TRUE`, sort the table in order of largest size
#' in the first row and smallest in the last row
#'
#' @return A data frame
#' @export
obj_sizes <- function(lst,
                      scale = c("b", "kb", "mb", "gb", "tb"),
                      desc = TRUE){

  scale <- match.arg(scale)

  if(scale == "b"){
    scale <- 1
    sc <- "B"
  }else if(scale == "kb"){
    scale <- 1e3
    sc <- "kB"
  }else if(scale == "mb"){
    scale <- 1e6
    sc <- "MB"
  }else if(scale == "gb"){
    scale <- 1e9
    sc <- "GB"
  }else if(scale == "tb"){
    scale <- 1e12
    sc <- "TB"
  }

  lst |>
    map_dbl(~as.numeric(object.size(.x)) / scale) |>
    sort(decreasing = desc) |>
    enframe() |>
    setNames(c("List element", paste0("Size (", sc, ")")))
}

#' Coerce an MCMC object to a time series
#'
#' @details
#' Copied from the `coda` package, it is the un-exported function
#' `as.ts.mcmc()``
#'
#' @param x An MCMC object [coda::mcmc()]
#' @param ... Unused arguments for compatibility with generic `as.ts`
#'
#' @return A [`stats::ts`] object
as_ts_mcmc <- function(x, ...){

  x <- as.mcmc(x)
  y <- ts(x,
          start = start(x),
          end = end(x),
          deltat = thin(x))
  attr(y, "mcpar") <- NULL

  y
}

#' Replace '+' with a newline in the given string
#'
#' @details
#' Used mainly for ggplot y axis labels, if they are too long
#' and get cut off
#'
#' @param x A character string
#' @param ... Absorbs other arguments not meant for this function
#'
#' @return A modified character string
add_newlines <- function(x, ...){
  gsub("\\+", "\n", x)
}

#' Stop the program without issuing an error message
#'
#' @param ... Arguments passed in to be written out as a message
#'
#' @return Nothing
#' @export
stop_quietly <- function(...) {
  opt <- options(show.error.messages = FALSE)
  on.exit(options(opt))
  message(unlist(list(...)))
  stop()
}

#' Format x to have supplied number of decimal points
#'
#' @details Make thousands separated by commas and the number of decimal
#' points given by `dec.points`
#'
#' @param x The number
#' @param dec.points The number of decimal points to use
#'
#' @return A formatted string representing the number
#' @export
f <- function(x, dec.points = 0){
  format(round(x, dec.points), big.mark = ",", nsmall = dec.points)
}

# Functions to make table generation easier -----------------------------------
# Latex newline
latex_nline <- " \\\\ "
# Horizontal line
latex_hline <- " \\hline "

#' Create a string with `n` ampersands separated by spaces
#'
#' @details The string will have one leading and one trailing space
#'
#' @param n The number of space-ampersands to return
#'
#' @return A string with `n` ampersands separated by spaces
#' @export
latex_amp <- function(n = 1){
  paste0(rep(" &", n), " ", collapse = "")
}

#' Create a string comprised of each element in the vector `vec` with an
#' ampersand in between
#'
#' @details The string will have one leading and one trailing space
#'
#' @param vec A vector of characters
#'
#' @return A string comprised of each element in the vector `vec` with an
#' ampersand in between
#' @export
latex_paste <- function(vec){
  paste(" ", vec, " ", collapse = " & ")
}

#' Wrap the given text with the latex \\textbf{} macro around it
#'
#' @param txt The text
#'
#' @return The given text with the latex \\textbf{} macro around it
#' @export
latex_bold <- function(txt){
  paste0("\\textbf{", txt, "}")
}

#' Wrap the given text with the latex \\emph{} macro around it
#'
#' @param txt The text
#'
#' @return The given text with the latex \\emph{} macro around it
#' @export
latex_italics <- function(txt){
  paste0("\\emph{", txt, "}")
}

#' Wrap the given text with the latex \\underline{} macro around it
#'
#' @param txt The text
#'
#' @return The given text with the latex \\underline{} macro around it
#' @export
latex_under <- function(txt){
  paste0("\\underline{", txt, "}")
}

#' Returns a string which has been glued together using multi-line-cell
#' macro for latex
#'
#' @param latex_vec A vector of the strings to glue together
#' @param make_bold Logical. If TRUE, make the text bold by inserting
#' a \\textbf{} macro
#'
#' @return A string
#' @export
latex_mlc <- function(latex_vec, make_bold = TRUE){
  if(make_bold){
    latex_vec <- sapply(latex_vec, latex_bold)
  }
  latex_str <- paste(latex_vec, collapse = latex_nline)
  paste0("\\mlc{", latex_str, "}")
}

#' Wrap the given text with the latex \\multicolumnn{} macro around it
#'
#' @param ncol The number of columns
#' @param just Justification, e.g. "l", "c", or "r" for left, center, right
#' @param txt The text
#'
#' @return The given text with the latex \\multicolumn{} macro around it
#' @export
latex_mcol <- function(ncol, just, txt){
  paste0("\\multicolumn{", ncol, "}{", just, "}{", txt, "}")
}

#' Wrap the given text with the latex \\multirow{} macro
#'
#' @param just Justification, e.g. "l", "c", or "r" for left, center, right
#' @param txt The text
#' @param nrow The number of rows in the multirow cell
#'
#' @return The given text wrapped in the latex \\multirow{} macro
#' @export
latex_mrow <- function(nrow, just, txt){
  paste0("\\multirow{", nrow, "}{", just, "}{", txt, "}")
}

#' Creates a string which has the given font size and space size applied
#'
#' @param fnt.size The font size
#' @param spc.size The space size (between text size)
#'
#' @return A string which has the given font size and space size applied
#' @export
latex_size_str <- function(fnt_size, spc_size){
  paste0("\\fontsize{", fnt_size, "}{", spc_size, "}\\selectfont")
}

#' Provide latex code to draw a horizontal line across the columns specified
#'
#' @param cols A string in this format: "1-3" which means the line should go
#' across columns 1 to 3
#'
#' @return A string of latex code to draw a horizontal line across the
#' columns specified
#' @export
latex_cline <- function(cols){
  paste0("\\cline{", cols, "}")
}

#' Provide latex code to draw a horizontal line across the columns specified
#'
#' @param cols A string in this format: "1-3" which means the line should go
#' across columns 1 to 3
#' @param trim Can be l, r, or lr and tells it to trim the line a bit so that
#' if there are two lines they don't touch in the middle. See `booktabs`
#'
#' @return As string of latex code to draw a horizontal line across the columns specified
#' @export
latex_cmidr <- function(cols, trim = "r"){
  paste0("\\cmidrule(", trim, "){", cols, "}")
}

#' Creates a latex string with `main_txt` subscripted by `subscr_txt`
#'
#' @param main_txt The main text to subscript
#' @param subscr_txt The subscript text
#'
#' @return A latex string with `main_txt` subscripted by `subscr_txt`
#' @export
latex_subscr <- function(main_txt, subscr_txt){
  paste0(main_txt, "\\subscr{", subscr_txt, "}")
}

#' Creates a latex string with `main_txt` superscripted by `supscr_txt`
#'
#' @param main_txt The main text to superscript
#' @param supscr_txt The superscript text
#'
#' @return A latex string with `main_txt` superscripted by `supscr_txt`
#' @export
latex_supscr <- function(main_txt, supscr_txt){
  paste0(main_txt, "\\supscr{", supscr_txt, "}")
}

#' Return the necessary latex to repeat longtable headers for continuing pages
#'
#' @param n_col The number of columns in the table
#' @param header The table header, needed for subsequent pages
#'
#' @return vector of strings needed to repeat the header of a longtable
#' and a footer which says 'Continued on next page ...'
#' @export
latex_continue <- function(n_col = 1, header = "Default"){
  paste0("\\endfirsthead \n",
         "\\multicolumn{",
         n_col,
         "}{l}{\\textit{... Continued from previous page}} \n",
         latex_nline,
         header,
         "\\endhead \n",
         latex_nline,
         latex_hline,
         "\\multicolumn{",
         n_col,
         "}{l}{\\textit{Continued on next page ...}} \n",
         "\\endfoot \n",
         "\\endlastfoot \n")
}

#' Extract priors information from a string with a particular format into
#' a vector
#'
#' @param prior_str A string with the format `Lognormal(2.0,1.01)`
#' @param dec_points The number of decimal points to use
#' @param first_to_lower Make the first letter of the prior name lower case
#'
#' @return A vector of length 3 with the following format:
#' `c("Lognormal", 2.0, 1.01)`
#' @export
split_prior_info <- function(prior_str,
                             dec_points = 1,
                             first_to_lower = FALSE){

  p <- strsplit(prior_str, "\\(")[[1]]

  if(first_to_lower){
    p[1] <- paste0(tolower(substr(p[1], 1, 1)),
                   substr(p[1],
                          2,
                          nchar(p[1])))
  }
  p_type <- p[1]
  p <- strsplit(p[2], ",")[[1]]
  p_mean <- f(as.numeric(p[1]), dec_points)
  p_sd <- f(as.numeric(gsub(")", "", p[2])), dec_points)

  c(p_type, p_mean, p_sd)
}

#' Create the age prop and the age itself for the ranking of age proportions
#'
#' @details Think of the question "Which is the second-highest number in
#' this vector and what is its index in the vector?" This function returns
#' a vector of those two numbers.
#'
#' @param vec A vector of age proportions
#' @param ranking 1 = max, 2 = second highest, etc.
#'
#' @return The age proportion and the age itself for the ranking of age
#' proportion
#' @export
get.age.prop <- function(vec, ranking = 1){
  prop <- rev(sort(vec))
  prop <- prop[ranking]
  age <- as.numeric(names(vec[vec == prop]))
  c(age, prop)
}

#' Create an RGB string of the specified color and opacity
#'
#' @details Format of returned string is #RRGGBBAA where
#' RR = red, a 2-hexadecimal-digit string
#' GG = green, a 2-hexadecimal-digit string
#' BB = blue, a 2-hexadecimal-digit string
#' AA = opacity, 2-digit string
#'
#' @param color A vector of R color strings or numbers
#' @param opacity A number between 0 and 99
#'
#' @return An RGB string of the specified color and opacity
#' @export
get.shade <- function(color, opacity){

  stopifnot(opacity > 0 & opacity < 100)

  colorDEC <- col2rgb(color)
  if(is.matrix(colorDEC)){
    colorHEX <- matrix(nrow = 3, ncol = ncol(colorDEC))
    shade <- NULL
    for(col in 1:ncol(colorDEC)){
      for(row in 1:nrow(colorDEC)){
        colorHEX[row, col] <- sprintf("%X", colorDEC[row,col])
        if(nchar(colorHEX[row,col]) == 1){
          colorHEX[row, col] <- paste0("0", colorHEX[row,col])
        }
      }
      shade[col] <- paste0("#",
                           colorHEX[1, col],
                           colorHEX[2, col],
                           colorHEX[3, col],
                           opacity)
    }
  }else{
    colorHEX <- sprintf("%X", colorDEC)
    for(i in 1:length(colorHEX)){
      if(nchar(colorHEX[i]) == 1){
        colorHEX[i] <- paste0("0", colorHEX[i])
      }
    }
    shade <- paste0("#", colorHEX[1], colorHEX[2], colorHEX[3], opacity)
  }
  shade
}

#' Pad the beginning of a number with zeroes
#'
#' @param num A vector of the numbers to pad
#' @param digits The number of characters that the resulting strings
#' should have
#'
#' @return A vector of strings of the padded numbers
#' @export
pad_num <- function(num, digits = 1){
  stopifnot(digits >= 1, !any(nchar(num) > digits))
  sapply(num,
         function(x){
           paste0(paste0(rep("0",
                             digits - nchar(as.character(x))),
                         collapse = ""),
                  as.character(x))})
}

t_pn <- function(){
  ## test pad_num
  cat("pad_num(0, 1) = ", pad_num(0, 1), "\n")
  cat("pad_num(1, 2) = ", pad_num(1, 2), "\n")
  cat("pad_num(10, 2) = ", pad_num(10, 2), "\n")
  cat("pad_num(10, 3) = ", pad_num(10, 3), "\n")
  cat("pad_num(10, 0) = ", pad_num(10, 0), "\n")
}

#' Change a number into an English word
#'
#' @details See
#'  https://github.com/ateucher/useful_code/blob/master/R/numbers2words.r
#' See Function by John Fox found here:
#'  http://tolstoy.newcastle.edu.au/R/help/05/04/2715.html
#' @param x The number to convert
#' @param th Logical. If TRUE the `th` versions will be returned,
#' e.g. 4 = fourth
#' @param cap_first Logical. Capitalize the first letter of the returned
#' string?
#'
#' @return The English word representing the number
#' @export
#'
#' @examples
#' number_to_word(c(1000,2,3,10000001), th = TRUE, cap_first = TRUE)
number_to_word <- function(x = NA, th = FALSE, cap_first = FALSE){

  stopifnot(!is.na(x))

  helper <- function(x){
    digits <- rev(strsplit(as.character(x), "")[[1]])
    nDigits <- length(digits)
    if(nDigits == 1) as.vector(ones[digits])
    else if(nDigits == 2)
      if(x <= 19) as.vector(teens[digits[1]])
    else trim(paste(tens[digits[2]],
                    Recall(as.numeric(digits[1]))))
    else if (nDigits == 3) trim(paste(ones[digits[3]], "hundred and",
                                      Recall(makeNumber(digits[2:1]))))
    else {
      nSuffix <- ((nDigits + 2) %/% 3) - 1
      if (nSuffix > length(suffixes)) stop(paste(x, "is too large!"), call. = FALSE)
      trim(paste(Recall(makeNumber(digits[
        nDigits:(3 * nSuffix + 1)])),
        suffixes[nSuffix],"," ,
        Recall(makeNumber(digits[(3 * nSuffix):1]))))
    }
  }
  trim <- function(text){
    ## Tidy leading/trailing whitespace, space before comma
    text=gsub("^\ ", "", gsub("\ *$", "", gsub("\ ,",",",text)))
    ## Clear any trailing " and"
    text=gsub(" and$","",text)
    ##Clear any trailing comma
    gsub("\ *,$","",text)
  }
  makeNumber <- function(...) as.numeric(paste(..., collapse=""))
  ## Disable scientific notation
  opts <- options(scipen=100)
  on.exit(options(opts))
  ones <- c("", "one", "two", "three", "four", "five", "six", "seven",
            "eight", "nine")
  names(ones) <- 0:9
  teens <- c("ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen",
             "sixteen", " seventeen", "eighteen", "nineteen")
  names(teens) <- 0:9
  tens <- c("twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty",
            "ninety")
  names(tens) <- 2:9
  x <- round(x)
  suffixes <- c("thousand", "million", "billion", "trillion")
  if (!th & length(x) > 1) return(trim(sapply(x, helper)))
  j <- sapply(x, helper)
  if(th){
    j <- sapply(j, function(x){
      tmp <- strsplit(x, " ")[[1]]
      first <- tmp[-length(tmp)]
      last <- tmp[length(tmp)]
      if(last == "one"){
        last <- "first"
      }else if(last == "two"){
        last <- "second"
      }else if(last == "three"){
        last <- "third"
      }else if(last == "five"){
        last <- "fifth"
      }else if(last == "eight"){
        last <- "eighth"
      }else if(last == "nine"){
        last <- "ninth"
      }else if(last == "twelve"){
        last <- "twelfth"
      }else if(last == "twenty"){
        last <- "twentieth"
      }else if(last == "thirty"){
        last <- "thirtieth"
      }else if(last == "forty"){
        last <- "fortieth"
      }else if(last == "fifty"){
        last <- "fiftieth"
      }else if(last == "sixty"){
        last <- "sixtieth"
      }else if(last == "seventy"){
        last <- "seventieth"
      }else if(last == "eighty"){
        last <- "eightieth"
      }else if(last == "ninety"){
        last <- "ninetieth"
      }else{
        last <- paste0(last, "th")
      }
      tmp <- paste(c(first, last), collapse = " ")
      if(cap_first){
        tmp <- paste0(toupper(substr(tmp, 1, 1)), substr(tmp, 2, nchar(tmp)))
      }
      tmp
    })
  }
  j
}

#' Create a character vector used in the align argument of the
#' [xtable::xtable()] command
#'
#' @details e.g. posterior output tables, reference point tables.
#' Most tables really
#'
#' @param num The number of columns in the table
#' @param first.left Logical. Keep the first column left-justified. If
#' `FALSE`, it will be justified according to the `just` argument
#' @param just The justification to use for the columns,
#' i.e. "r", "l", or "c"
#'
#' @return A character vector used in the align argument of the [xtable::xtable()] command
#' @export
get.align <- function(num,
                      first.left = TRUE,
                      just = "r"){

  if(first.left){
    align <- c("l", "l")
  }else{
    align <- c(just, just)
  }
  for(i in 1:(num-1)){
    align <- c(align, just)
  }
  return(align)
}

#' Create rich colors as RGB strings
#'
#' @param n The number of colors
#' @param alpha The transparency for all colors
#'
#' @return A vector of RGB strings representing rich colors
#' @export
#'
#' @examples
#' rich.colors.short(10)
rich.colors.short <- function(n, alpha = 1){

  x <- seq(0, 1, length = n)
  r <- 1/(1 + exp(20 - 35 * x))
  g <- pmin(pmax(0, -0.8 + 6 * x - 5 * x ^ 2), 1)
  b <- dnorm(x, 0.25, 0.15)/max(dnorm(x, 0.25, 0.15))
  rgb.m <- matrix(c(r, g, b), ncol = 3)
  apply(rgb.m, 1, function(v) rgb(v[1], v[2], v[3], alpha = alpha))
}

#' Plot bars
#'
#' @param x The x axis values (i.e., years)
#' @param y A data frame with columns:
#' value: estimate (point) to plot
#' lo: lower CI
#' hi: higher CI
#' @param gap Gap size for the segments
#' @param add Logical. If `TRUE`, add to the current plot, if `FALSE`,
#' create a new plot
#' @param ciCol Credible interval color
#' @param ciLty Credible interval line type
#' @param ciLwd Credible interval width
#' @param scale Amount to divide y-axis values by
#' @param ... Absorbs arguments meant for other functions
#'
#' @return [base::invisible()]
#' @export
plotBars.fn <- function(x,
                        y,
                        scale = 1,
                        gap = 0,
                        add = FALSE,
                        ciCol = "black",
                        ciLty = 1,
                        ciLwd = 1,
                        ...) {

  y$value <- y$value / scale
  y$lo <- y$lo / scale
  y$hi <- y$hi / scale

  if(!add) plot(x, y$value, ...)
  if(add) points(x, y$value, ...)
  segments(x, y$lo, x, y$value - gap, col = ciCol, lty = ciLty, lwd = ciLwd)
  segments(x, y$hi, x, y$value + gap, col = ciCol, lty = ciLty, lwd = ciLwd)
  invisible()
}

#' Add a letter to the plot
#'
#' @param letter The letter to add
#'
#' @return [base::invisible()]
#' @export
panel.letter <- function(letter){

  usr <- par("usr")
  inset.x <- 0.05 * (usr[2] - usr[1])
  inset.y <- 0.05 * (usr[4] - usr[3])
  text(usr[1] + inset.x,
       usr[4] - inset.y,
       paste0("(", letter, ")"), cex = 1.0, font = 1)
}

#' Add a polygon to a plot
#'
#' @param yrvec A vector of years
#' @param lower A vector of lower CI values
#' @param upper A vector of upper CI values
#' @param color The color to make the polygon lines
#' @param shade.col The shade color to fill in the polygon with
#'
#' @return [base::invisible()]
#' @export
addpoly <- function(yrvec,
                    lower,
                    upper,
                    color = 1,
                    shade.col = NA){

  # max of value or 0
  lower[lower < 0] <- 0
  if(is.na(shade.col)){
    shade.col <- rgb(t(col2rgb(color)), alpha = 0.2 * 255, maxColorValue = 255)
  }
  polygon(x = c(yrvec, rev(yrvec)),
          y = c(lower, rev(upper)),
          border = NA,
          col = shade.col)
  lines(yrvec, lower, lty = 3, col = color)
  lines(yrvec, upper, lty = 3, col = color)
  invisible()
}

#' Get a vector of the active parameter names for a model
#'
#' @param model A model object as returned from [create_rds_file()]
#'
#' @return A vector of the active parameter names for a model
#' @export
get_active_parameter_names <- function(model){
  params <- model$parameters
  params$Label[!is.na(params$Active_Cnt)]
}

#' Get the posterior values for the given regular expressions of
#' parameter names
#'
#' @param model The SS model output as loaded by [create_rds_file()]
#' @param param_regex A vector of regular expressions used to extract data
#' for parameter names. If there are no matches, or more than one for any
#' regular expression, the program will stop
#'
#' @return A list of posterior vectors, one for each of the regular
#' expressions in `param_regex`
#' @export
#' @examples
#' \dontrun{
#' get_posterior_data(base_model, "BH_steep")
#' get_posterior_data(base_model, "e")
#' get_posterior_data(base_model, "asdfg")
#' get_posterior_data(base_model, c("NatM", "SR_LN", "SR_BH_steep",
#'  "Q_extraSD"))
#' }
get_posterior_data <- function(model, param_regex){

  mcmc <- model$mcmc
  if(length(mcmc) == 1 && is.na(mcmc)){
    return(NA)
  }

  params <- model$parameters
  posts_list <- list()

  for(i in seq_along(param_regex)){
    parind <- grep(param_regex[i], params$Label)
    if(length(parind) < 1){
      stop("The regular expression ", param_regex[i],
           " matched no parameter names", call. = FALSE)
    }
    if(length(parind) > 1){
      stop("The regular expression ", param_regex[i],
           " matched more than one (", length(parind),
           ") parameter names", call. = FALSE)
    }
    postparname <- params[parind, ]$Label
    message("The regular expression matched ", postparname)

    # Figure out which column of the mcmc output contains the parameter
    jpar <- grep(param_regex[i], names(mcmc))
    if(length(jpar) == 1){
      posts_list[[i]] <- mcmc[ ,jpar]
    }else{
      warning("Parameter ", postparname, " not found in posteriors")
      posts_list[[i]] <- NA
    }
  }

  #if(length(posts_list) == 1){
  #  posts_list <- posts_list[[1]]
  #}
  posts_list
}

#' Get the prior and MLE values for the given regular expressions of
#' parameter names
#'
#' @param model The SS model output as loaded by [create_rds_file()]
#' @param param_regex A vector of regular expressions used to extract data
#' for parameter names. If there are no matches, or more than one for any
#' regular expression, the program will stop.
#' @param n_points_prior An integer specifying the number of points you want to
#'   be generated from the `r<distribution>()` function, e.g.,
#'   `rnorm(n_points_prior)`.
#'
#' @return A list of prior and MLE data, one for each of the regular
#' expressions in `param_regex`
#' @export
#' @examples
#' \dontrun{
#' get_prior_data(base_model, "BH_steep")
#' get_prior_data(base_model, "e")
#' get_prior_data(base_model, "asdfg")
#' get_prior_data(base_model, c("NatM", "SR_LN", "SR_BH_steep", "Q_extraSD"))
#' }
get_prior_data <- function(model, param_regex, n_points_prior = 3000000){

  stopifnot(class(param_regex) == "character")

  params <- model$parameters
  priors_list <- list()
  Pconst <- 0.0001

  for(i in seq_along(param_regex)){
    parind <- grep(param_regex[i], params$Label)
    if(length(parind) < 1){
      stop("The regular expression ", param_regex[i],
           " matched no parameter names", call. = FALSE)
    }
    if(length(parind) > 1){
      stop("The regular expression ", param_regex[i],
           " matched more than one (", length(parind),
           ") parameter names", call. = FALSE)
    }
    parline <- params[parind, ]
    message("The regular expression matched ", parline$Label)
    initval <- parline$Init
    finalval <- parline$Value
    parsd <- parline$Parm_StDev

    Pmin <- parline$Min
    Pmax <- parline$Max

    Ptype <- ifelse(is.na(parline$Pr_type), "Normal", parline$Pr_type)
    Psd <- parline$Pr_SD
    Pr <- parline$Prior
    Pval <- seq(Pmin, Pmax, length = nrow(model$mcmc))

    if(Ptype == "Log_Norm"){
      Prior_Like <- 0.5 * ((log(Pval) - Pr) / Psd) ^ 2
    }else if(Ptype == "Full_Beta"){
      mu <- (Pr - Pmin) / (Pmax - Pmin);  # CASAL's v
      tau <- (Pr - Pmin) * (Pmax - Pr) / (Psd ^ 2) - 1.0
      Aprior <- tau * (1 - mu)  # CASAL's m and n
      Bprior <- tau * mu
      if(Aprior <= 1.0 | Bprior <= 1.0) {
        warning("Bad Beta prior for parameter ", parline$Label)
      }
      Prior_Like <- (1.0 - Bprior) * log(Pconst + Pval - Pmin) +
        (1.0 - Aprior) * log(Pconst + Pmax - Pval) -
        (1.0 - Bprior) * log(Pconst + Pr - Pmin) -
        (1.0 - Aprior) * log(Pconst + Pmax - Pr)
    }else if(Ptype == "No_prior"){
      Prior_Like <- rep(0.0, length(Pval))
    }else if(Ptype == "Normal"){
      Prior_Like <- 0.5*((Pval - Pr) / Psd) ^ 2
    }else{
      warning("No prior found for parameter ", parline$Label)
      Prior_Like <- NA
    }

    prior <- NA
    if(!is.na(Prior_Like[1])){
      prior <- exp(-1 * Prior_Like)
    }

    mle <- NULL
    if(!is.na(parsd) && parsd > 0){
      mle <- dnorm(Pval, finalval, parsd)
      mlescale <- 1 / (sum(mle) * mean(diff(Pval)))
      mle <- mle * mlescale
    }

    random_points <- switch(
      Ptype,
      "Normal" = rnorm(n_points_prior, Pr, Psd),
      "Log_Norm" = rlnorm(n_points_prior, Pr, Psd),
      "Full_Beta" = rbeta_ab(n_points_prior, Pr, Psd, min = Pmin, max = Pmax),
      "No_prior" = runif(n_points_prior, min = Pmin, Pmax)
    )
    random_points[random_points < Pmin | random_points > Pmax] <- NA

    priors_list[[i]] <- list(initval = initval,
                             finalval = finalval,
                             parsd = parsd,
                             Pmin = Pmin,
                             Pmax = Pmax,
                             Ptype = Ptype,
                             Psd = Psd,
                             Pr = Pr,
                             Pval = Pval,
                             prior = prior,
                             mle = mle,
                             prior_random = random_points)

  }

  priors_list
}

#' The Beta distribution
#'
#' @details
#' Random generation for the Beta distribution with parameters based on the
#' mean and standard deviation as well as the ranges as implemented in
#' CASAL. This formulation is also available on [Wikipedia](
#' https://en.wikipedia.org/wiki/Beta_distribution#Mean_and_variance).
#' This function is a direct copy of the code available from [Wetzel and Punt](
#' https://github.com/chantelwetzel-noaa/XSSS/blob/4dce917ee06d52416b58dd9440796ba1f7357943/R/rbeta_ab_fn.R).
#'
#' @param prior Prior value
#' @param sd Standard deviation
#' @param min Minimum value
#' @param max Maximum value
#' @param n The number of random values you want in the returned vector.
#'
#' @return A vector of doubles, where the length of the vector depends on the
#' length of `x` value passed to `n`.
#' `dbeta_ab` returns density estimates for each input value and `rbeta_ab`
#' provides random deviates from the Beta distribution.
#'
#' @export
rbeta_ab <- function(n, prior, sd, min, max) {
  # CASAL's Beta
  mu <- (prior - min) / (max - min)
  tau <- (prior - min) * (max - prior) / (sd ^ 2) - 1.0
  alpha <- tau * mu
  beta <- tau * (1 - mu)
  b_std <- rbeta(n, alpha, beta)

  # linear transformation from beta(0, 1) to beta(a, b)
  (max - min) * b_std + min
}

#' @param x X value for distribution
#' @rdname rbeta_ab
#' @export
dbeta_ab <- function(x, prior, sd, min, max) {

  p_const <- 0.0001
  mu <- (prior - min) / (max - min) # CASAL's v
  tau <- (prior - min) * (max - prior) / (sd^2) - 1.0
  b_prior <- tau * mu
  # CASAL's m and n
  a_prior <- tau * (1 - mu)
  if(b_prior <= 1.0 | a_prior <= 1.0){
    warning("Bad Beta prior")
  }

  (1.0 - b_prior) * log(p_const + x - min) +
    (1.0 - a_prior) * log(p_const + max - x) -
    (1.0 - b_prior) * log(p_const + prior - min) -
    (1.0 - a_prior) * log(p_const + max - prior)
}

#' Updates [ggplot2::label_parsed()] to accommodate spaces
#'
#' @param labels Labels to use
label_parsed_space <- function(labels) {

  labels <- label_value(labels, multi_line = TRUE)
  labels <- lapply(labels, function(y) gsub(" ", "~", y))
  lapply(unname(labels), lapply, function(values) {
    c(parse(text = as.character(values)))
  })
}

#' Split the posteriors data frame in a list of N data frames based on
#' `from_to`
#'
#' @param df A data frame containing rows to split
#' @param from_to A data frame with the columns `from` and `to` which
#' indicate the rows from and to for each data frame
#'
#' @return A list of data frames of the same length as the number of
#' rows in `from_to`
#' @export
split_df <- function(df, from_to){
  stopifnot(nrow(df) >= max(from_to))
  pmap(from_to, ~{df[.x:.y,]})
}

#' Calculate and insert columns containing arbitrary quantiles for a
#' particular column
#'
#' @param df A [data.frame()]
#' @param col A column name on which to perform the calculations. Must
#' be in `df` or an error will be thrown
#' @param probs A vector of quantile probabilities to pass to
#' [stats::quantile()]
#' @param include_mean Logical. If `TRUE`, include the mean in the output
#'
#' @return A [data.frame()] with a new column for each value in the `probs`
#' vector
#' @export
#' @examples
#' library(tibble)
#' library(dplyr)
#' library(purrr)
#' pq <- tribble(
#'   ~year, ~grp, ~val,
#'   2000,    1,  2.1,
#'   2001,    1,  3.4,
#'   2002,    1,  4.5,
#'   2003,    1,  5.6,
#'   2004,    1,  6.7,
#'   2000,    2,  3.1,
#'   2001,    2,  4.4,
#'   2002,    2,  5.5,
#'   2003,    2,  6.6,
#'   2004,    2,  8.7,
#'   2000,    3, 13.1,
#'   2001,    3, 14.4,
#'   2002,    3, 15.5,
#'   2003,    3, 16.6,
#'   2004,    3, 18.7)
#'
#' probs <- c(0.05, 0.25, 0.5, 0.75, 0.95)
#'
#' yrs <- sort(unique(pq$year))
#' df <- pq %>%
#'   group_by(year) %>%
#'   group_map(~ calc_quantiles(.x, col = "val", probs = probs)) %>%
#'   map_df(~{.x}) %>%
#'   mutate(year = yrs) %>%
#'   select(year, everything())
calc_quantiles <- function(df = NULL,
                           col = NULL,
                           probs = c(0.05, 0.25, 0.5, 0.75, 0.95),
                           include_mean = TRUE){

  stopifnot(col %in% names(df))
  stopifnot(class(df[[col]]) == "numeric")
  col_sym <- sym(col)
  out <- summarize_at(df,
                      vars(!!col_sym),
                      map(probs,
                          ~partial(quantile, probs = .x, na.rm = TRUE)) %>%
                        set_names(probs))

  if(include_mean){
    out <- out %>%
      mutate(avg = mean(df[[col]]))
  }
  out
}

#' Calculate quantiles across groups for a given column
#'
#' @rdname calc_quantiles
#'
#' @param df A [data.frame] with columns with names given by `grp_col`
#' and `col`
#' @param grp_col The column name to use for grouping the data
#' @param col The column name to use as values to calculate quantiles for
#' @param probs A vector of quantiles to pass to [stats::quantile()]
#' @param include_mean If TRUE, include the mean in the output
#' @param grp_names The column name to use for labeling the grouped column. By
#' default it is the same as the
#' grouping column (`grp_col`).
#'
#' @return A [data.frame()] containing the quantile values with one row per
#' group represented by `grp_col`
#' @export
#'
#' @examples
#' library(tibble)
#' library(dplyr)
#' library(purrr)
#' pq <- tribble(
#'   ~year, ~grp, ~val,
#'   2000,    1,  2.1,
#'   2001,    1,  3.4,
#'   2002,    1,  4.5,
#'   2003,    1,  5.6,
#'   2004,    1,  6.7,
#'   2000,    2,  3.1,
#'   2001,    2,  4.4,
#'   2002,    2,  5.5,
#'   2003,    2,  6.6,
#'   2004,    2,  8.7,
#'   2000,    3, 13.1,
#'   2001,    3, 14.4,
#'   2002,    3, 15.5,
#'   2003,    3, 16.6,
#'   2004,    3, 18.7)
#'
#' probs <- c(0.05, 0.25, 0.5, 0.75, 0.95)
#'
#' j <- calc_quantiles_by_group(pq,
#'                              grp_col = "year",
#'                              col = "val",
#'                              probs = probs)
calc_quantiles_by_group <- function(df = NULL,
                                    grp_col = NULL,
                                    col = NULL,
                                    grp_names = grp_col,
                                    probs = c(0.05, 0.25, 0.5, 0.75, 0.95),
                                    include_mean = TRUE){

  stopifnot(grp_col %in% names(df))
  stopifnot(col %in% names(df))

  grp_col_sym <- sym(grp_col)
  grp_names_sym <- sym(grp_names)
  col_sym <- sym(col)
  grp_vals <- unique(df[[grp_names]])

  df %>%
    group_by(!!grp_col_sym) %>%
    group_map(~ calc_quantiles(.x, col = col,
                               probs = probs,
                               include_mean = include_mean)) %>%
    map_df(~{.x}) %>%
    mutate(!!grp_names_sym := grp_vals) %>%
    select(!!grp_names_sym, everything()) %>%
    ungroup()
}

#' Call [shell()] or [system()] depending on the Operating System
#'
#' @details
#' Copy `files` and their containing directories from all subdirectories
#' of `fromdir` to `todir`. Only subdirs of `fromdir` are searched for
#' `files`, not `fromdir` itself, and there is no recursion.
#'
#' @param fromdir The directory to copy subdirectories and their `files` from
#' @param todir The directory to copy subdirectories and their `files` to
#' @param files A character vector of file names to include in the copy
#' @param overwrite If `todir` exists then overwrite its subdirs if they exist.
#' Everything else in `todir` not pertaining to the copy will remain after the
#' overwrite
#' @param ignore_missing_files If `FALSE` and any of `files` are missing in
#' subdirectories of `fromdir`, code execution will stop and an error will
#' be shown. If `TRUE`, missing files will be ignored
#'
#' @return Nothing
#' @export
copy_dirfiles <- function(fromdir = getwd(),
                          todir = NULL,
                          files = c("starter.ss",
                                    "forecast.ss",
                                    "hake_control.ss",
                                    "hake_data.ss",
                                    "wtatage.ss"),
                          overwrite = TRUE,
                          ignore_missing_files = TRUE){

  if(is.null(fromdir)){
    stop("You must provide a directory to copy from (fromdir)",
         call. = FALSE)
  }
  if(!dir.exists(fromdir)){
    stop("The fromdir directory '", fromdir, "' does not exist",
         call. = FALSE)
  }
  if(is.null(todir)){
    stop("You must provide a directory to copy to (todir)",
         call. = FALSE)
  }
  if(is.null(files)){
    stop("You must provide a vector of filenames to copy (files)",
         call. = FALSE)
  }
  if(as.character(class(files)) != "character"){
    stop("Your files vector must be a character vector", call. = FALSE)
  }
  if(dir.exists(todir)){
    if(!overwrite){
      stop("The todir directory '",
           todir,
           "' exists and overwrite is set to FALSE",
           call. = FALSE)
    }
  }

  dirs <- list.dirs(fromdir, recursive = FALSE)
  if(!length(dirs)){
    warning("No subdirectories were found in the ", fromdir, " directory")
    return(NULL)
  }

  dir.create(todir, showWarnings = FALSE)
  for(path in dirs){
    subdir_name <- basename(path)
    new_subdir <- file.path(todir, subdir_name)
    dir.create(new_subdir, showWarnings = FALSE)
    cp_flags <- suppressWarnings(file.copy(file.path(path, files),
                                           new_subdir,
                                           overwrite = TRUE))
    if(!ignore_missing_files && !all(cp_flags)){
      stop("Could not copy the file(s):\n",
           paste(file.path(path, files[!cp_flags]),
                 collapse = "\n"),
           call. = FALSE)
    }
    # Make sure starter file is lowercase
    if(file.exists(file.path(new_subdir, "starter.SS"))){
      system_(paste0("cd ", new_subdir, " && mv starter.SS starter.ss"))
    }
    # Change Uppercase SS extensions in the starter file to lowercase
    starter_file <- file.path(path, "starter.ss")
    if(file.exists(starter_file)){
      starter <- readLines(starter_file)
      ss_inds <- grep("hake_.*SS", starter)
      if(length(ss_inds)){
        starter[ss_inds] <- gsub("SS", "ss", starter[ss_inds])
        writeLines(starter, starter_file)
      }
    }
    # Make sure all the input files other than starter file are lowercase
    if(file.exists(file.path(new_subdir, "hake_control.SS"))){
      system_(paste0("cd ", new_subdir,
                     " && mv hake_control.SS hake_control.ss"))
    }
    if(file.exists(file.path(new_subdir, "hake_data.SS"))){
      system_(paste0("cd ", new_subdir, " && mv hake_data.SS hake_data.ss"))
    }
    if(file.exists(file.path(new_subdir, "wtatage.SS"))){
      system_(paste0("cd ", new_subdir, " && mv wtatage.SS wtatage.ss"))
    }
    if(file.exists(file.path(new_subdir, "forecast.SS"))){
      system_(paste0("cd ", new_subdir, " && mv forecast.SS forecast.ss"))
    }
  }
  message("Copied all subdirectories and given files from '",
          fromdir,
          "' to '",
          todir, "'")
}

#' Change the MCMC setting in an SS starter file so the extra MCMC files are
#' not created
#'
#' @param path The path where `starter.ss` resides
#' @param value Value to change the MCMC setting to. 1 = Do not create extra
#' MCMC files, 2 or 3 - create extra MCMC files
#'
#' @return Nothing
#' @export
modify_starter_mcmc_type <- function(path, value){

  # Make a modification to the starter file
  if(!dir.exists(path)){
    stop("The directory ", path, " does not exist",
         call. = FALSE)
  }
  if(!file.exists(file.path(path, starter_file_name))){
    stop("The file ", file.path(path, starter_file_name), " does not exist",
         call. = FALSE)
  }
  starter_contents <- readLines(file.path(path,
                                          starter_file_name))
  mcmc_output_ind <- grep("MCMC output detail|MCMC_output_detail",
                          starter_contents)
  mcmc_output_val <- starter_contents[mcmc_output_ind]
  mcmc_output_val <- gsub("^.*(#.*)",
                          "\\1",
                          mcmc_output_val)
  mcmc_output_val <- paste0(value,
                            " ",
                            mcmc_output_val,
                            " - *Modified by modify_starter_mcmc_type()*")
  starter_contents[mcmc_output_ind] <- mcmc_output_val
  writeLines(starter_contents, file.path(path, starter_file_name))
}

